4.4.47 - Bellman-Ford negative cycle detection

As seen on Proposition X in the book, for any vertex t that is reachable from s, consider a specific shortest path from s to t: v0 -> v1 -> ... -> vk, where v0 is s and vk is t. If there are no negative cycles, such a path exists and k can be no larger than V - 1. We show by induction on i that after the ith pass the algorithm computes a shortest path from s to vi.
The base case (i = 0) is trivial. Assuming the claim to be true for i, v0 -> v1 -> ... -> vi is a shortest path from s to vi, and distTo[vi] is its length. Now, we relax every edge in the ith pass, including vi -> vi+1, so distTo[vi+1] is no greater than distTo[vi] plus the weight of vi -> vi+1. Now, after the ith pass, distTo[vi+1] must be equal to distTo[vi] plus the weight of vi -> vi+1. It cannot be greater because we relax every edge in the ith pass, in particular vi -> vi+1, and it cannot be less because that is the length of v0 -> v1 -> ... -> vi+1, a shortest path. Thus the algorithm computes a shortest path from s to vi+1 after the (i+1)st pass when there are no negative cycles reachable from s.
The highest possible number of edges in a shortest path is V - 1, which is a path that passes through all vertices in the graph. So, if there are no negative cycles reachable from s, all shortest paths will be computed after the V - 1st pass of the algorithm, and no edges will be relaxed in any future passes, including the Vth pass.
Therefore, if any edge is relaxed during the Vth pass of the generic Bellman-Ford algorithm it means that a new shortest path has been found, using V edges. This would only be possible in the presence of a negative cycle. Since the edgeTo[] array stores the edges on the shortest paths found, it will have a directed cycle, and any such cycle is a negative cycle.